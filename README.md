В данном проекте реализован мост между двумя блокчейнами

Основной контракт - bridge.sol

Данный контракт деплоится в двух разных сетях и позволяет обмениватся токенами между сетями

Описание полей контракта:

-- counter
Счётчик транзакций - каждой транзакции назначиается уникальный счётчик, благодаря чему невозможно дважды получить одну и ту же транзакцию

-- currentChainId
id блокчейна в котором расположен данный мост

-- owner
Адрес владельца контракта

-- bridgeOwner
Роль владельца контракта

-- administrator
Роль администратора контракта, она очень важна - именно ключом администратора подписывается сигнатура

-- _roles
Словарь с ролями

-- tokens
В данной реализации токены индифицируются по названию
В словаре хранится соответствие адреса токена его названию

-- chainIds
Словарь в котором хранятся id блокчейнов, которые поддерживает мост

-- counters
Словарь в котором хранятся информация о выполненных транзакциях
Поскольку мост может поддерживать работу с несколькими блокчейнами - для каждого id блокчейна отдельно сохраняются id выполненных транзакций


Описание функций контракта:

-- Constructor(uint256 _currentChainId)
Принимает один аргумент - id того блокчейна, в который он деплоится
также в конструкторе создаются роли bridgeOwner и administrator
также в конструкторе инициализируется 0 переменная counter

-- swap(string memory tokenName, address recipient, uint256 chainId, uint256 value)
Функция принимает следующие аргументы
- tokenName - имя токена, который надо переслать
- recipient - адрес получателя в другом блокчейне
- chainId - id блокчейна, в который отправляются токены
- value - количество пересылаемых токенов

Функия вызывает revert если:
- chainId нет в списке поддерживаемых блокчейнов
- tokenName нет в списке поддерживаемых токенов

Далее функция сжигает value токенов на адресе msg.sender
Для этого необходимо выдать роль админа на контракте токена контракту моста

вызывает евент swapInitialized

-- event swapInitialized( 
        uint256 currentChainId,
        string tokenName,
        address recipient,
        uint256 chainId,
        uint256 value,
        uint256 counter
    );
Евент принимает следующие аргументы:
- currentChainId - id текущего блокчейна
- tokenName - имя отправляемого токенами
- recipient - адрес получателя
- chainId - id блокчейна, куда токены отправляются
- value - количество отправляемых токенов
- counter - счётчик операции

--  function redeem(
        uint256 chainId,
        string memory tokenName,
        uint256 value,
        uint256 _counter,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) 
Функция принимает следующие аргументы
- chainId - id цепочки из которой получены токены
- tokenName - имя полученного токена
- value - количество полученных токенов
- _counter - id транзакции в мосте блокчейна chainId

Функия вызывает revert если:
- chainId нет в списке поддерживаемых блокчейнов
- tokenName нет в списке поддерживаемых токенов
- транзакция с счётчиком _counter из chainId уже выполнена
- функция checkSign() вернула false

Далее функция минтит value токенов tokenName на адрес msg.sender
Сохраняет в словарь counters информацию, что транзакция с id _counter из блокчейна chainId выполнена

-- checkSign(...)
-- hashMessage(...)
проверяют подпись

-- updateChainById(uint256 chainId, bool update)
Добавляет/удаляет id блокченов в мост
Функцию могут вызывать только хозяин контракта моста или его администратор

-- includeToken(address tokenAddress)
Добавляет токен по его адресу в мост
Вызывает revert, если токен уже добавлен
Функцию могут вызывать только хозяин контракта моста или его администратор

-- excludeToken(address tokenAddress)
Удаляет токен по его адресу в мост
Вызывает revert, если токен не добавлен
Функцию могут вызывать только хозяин контракта моста или его администратор

////////////////////////////////////////////////////////////////////////

Также реализованы тесты

testERC20.ts - тест контракта токена

testBridge.ts - тест контракта моста

В этом тесте присутствует некоторая условность - мосты и токены деплоятся в одной тестовой сети
При этом вся остальная логика работы мостов соблюдена, тесты имеют 100% покрытие

////////////////////////////////////////////////////////////////////////

Также реализован скрипт для деплоя

Скрипт не только деплоит мост, но и выполняет некоторые дополнительные действия:
- деплоит контракт токена
- минтит токены
- выдаёт роль админа контракту моста на контракте токена
- выдаёт роль админа бекенду на контракте моста

Скрипт подходит как для Eth так и для Bsc - только надо поменять пару значений - смотрите внимательно комментарии в скрипте

////////////////////////////////////////////////////////////////////////

Также реализованы таски

-- swap

принимает аргументы
- bridgeAddress - адрес контракта моста
- tokenName - имя токена, который необходимо переслать
- recipientAddress - адрес получателя в другой сети
- chainId - id другого блокчейна
- value - количество отправляемых токенов

таск подключается к контрактам моста и токена
вызывает функцию swap на контракте моста
и выводит много полезной информации, в том числе, информации необходимой для вызова функции redeem на контракте моста в другом блокчейне

-- redeem

принимает аргументы
- bridgeAddress - адрес контракта моста
- chainId - id блокчейна из которого отправлены токены
- tokenName - имя отправленных токенов
- value - количество отправляемых токенов
- counter - значение счётчика транзакций в блокчейне chainId
- v, r, s - значения сигнатуры

таск подключается к контрактам моста и токена
вызывает функцию redeem на контракте моста
и выводит много полезной информации, в том числе, об изменении баланса после выполения redeem

////////////////////////////////////////////////////////////////////////

Контракты токена и моста задеплоины в тестовых сетях Eth и Bsc при помощи скрипта deploy.ts
по адресам:

ETH:
Token erc20 deployed to: 0x677ba7DBd04222c682207332F9D59408217cc87f
Bridge deployed to: 0x3038745f3f7df9E8CCcb0aC62bcA7e3F888a02b2

BSC:
Token erc20 deployed to: 0xD4639d4a97719569C427d4589B8e94f270fbe895
Bridge deployed to: 0x8CcE2099DFF96B4d81589Bc82a95Cc4318B6f2e1

Контракты верифицированы

Работа контрактов проверена при помощи тасок swap и redeem